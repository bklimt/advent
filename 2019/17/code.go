package main

import (
	"fmt"
)

type Position struct {
	X int
	Y int
}

func main() {
	p := ReadProgram()
	in := make(chan int)
	out := make(chan int)
	wantInput := make(chan bool)
	c := NewComputer(p, in, out, wantInput)
	c.Memory[0] = 2
	go func() {
		c.Run()
	}()

	// Supply the input programming.
	go func() {
		s := "A,B,A,C,A,B,C,B,C,A\nL,12,R,4,R,4,L,6\nL,12,R,4,R,4,R,12\nL,10,L,6,R,4\n"
		for _, c := range s {
			<-wantInput
			in <- int(c)
		}
		<-wantInput
		in <- 'y'
		<-wantInput
		in <- '\n'
	}()

	screen := make(map[Position]int)
	cursor := Position{}
	size := Position{}

	for {
		c, ok := <-out
		if !ok {
			break
		}

		if c > 127 {
			fmt.Printf("\nRESULT: %d\n", c)
			continue
		}

		fmt.Printf("%c", c)
		screen[cursor] = c
		if c == 10 {
			cursor.X = 0
			cursor.Y++
		} else {
			cursor.X++
		}
		if cursor.X > size.X {
			size.X = cursor.X
		}
		if cursor.Y > size.Y {
			size.Y = cursor.Y
		}
	}
	close(in)

	fmt.Println()
	fmt.Println()

	/*
		xs := make([]Position, 0)
		sum := 0
		for y := 0; y <= size.Y; y++ {
			for x := 0; x <= size.X; x++ {
				c, ok := screen[Position{X: x, Y: y}]
				if !ok {
					fmt.Print(" ")
				} else {
					fmt.Printf("%c", c)
				}

				if c == 35 {
					if screen[Position{X: x - 1, Y: y}] == 35 &&
						screen[Position{X: x + 1, Y: y}] == 35 &&
						screen[Position{X: x, Y: y - 1}] == 35 &&
						screen[Position{X: x, Y: y + 1}] == 35 {
						xs = append(xs, Position{X: x, Y: y})
						sum = sum + x*y
					}
				}
			}
		}
		fmt.Println()

		for _, x := range xs {
			fmt.Printf("%v\n", x)
		}
		fmt.Printf("\n%d\n", sum)
	*/
}

// 1: 3292
// 2: 651043

/*

....................................#####......
....................................#...#......
....................................#...#......
....................................#...#......
#####.......................#############......
#...#.......................#.......#..........
#...#.......................#.......#..........
#...#.......................#.......#..........
#############.............#####.....#..........
....#.......#.............#.#.#.....#..........
....#.......#.............#.#.#.###########....
....#.......#.............#.#.#.#...#.....#....
....#.......#.............#.#.#######.....#....
....#.......#.............#.#...#.........#....
....#...#####.............#.#######.......#....
....#...#.................#.....#.#.......#....
....#############.........#.#####.#.......#....
........#.......#.........#.#.....#.......#....
........############^.....#.#.....#############
................#.........#.#.............#...#
............#####.....#####.#.............#...#
............#.........#.....#.............#...#
............#.........#.....#.............#####
............#.........#.....#..................
............#.....#######...#..................
............#.........#.#...#..................
............###########.#...#..................
........................#...#..................
........................#####..................

// Uncompressed
L,12,R,4,R,4,L,6,
L,12,R,4,R,4,R,12,
L,12,R,4,R,4,L,6,
L,10,L,6,R,4,
L,12,R,4,R,4,L,6,
L,12,R,4,R,4,R,12,
L,10,L,6,R,4,
L,12,R,4,R,4,R,12,
L,10,L,6,R,4,
L,12,R,4,R,4,L,6

A=L,12,R,4,R,4,L,6
B=L,12,R,4,R,4,R,12
C=L,10,L,6,R,4

A,B,A,C,A,B,C,B,C,A

*/
